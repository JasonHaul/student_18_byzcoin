syntax = "proto2";

import "darc.proto";

option java_package = "ch.epfl.dedis.proto";
option java_outer_classname = "TransactionProto";

// ***
// These are the messages used in the API-calls
// ***

// Instruction holds only one of Spawn, Invoke, or Delete
message Instruction {
  // 	 ObjectID holds the id of the existing object that can spawn new objects.
  // 	 It is composed of the Darc-ID + a random value generated by omniledger.
  required ObjectID objectid = 1;
  // 	 Nonce is monotonically increasing with regard to the darc in the objectID
  // 	 and used to prevent replay attacks.
  // 	 The client has to track which is the current nonce of a darc-ID.
  required bytes nonce = 2;
  // 	 Index and length prevent a leader from censoring specific instructions from
  // 	 a client and still keep the other instructions valid.
  // 	 Index is relative to the beginning of the clientTransaction.
  required sint32 index = 3;
  // 	 Length is the total number of instructions in this clientTransaction
  required sint32 length = 4;
  // 	 Spawn creates a new object
  optional Spawn spawn = 5;
  // 	 Invoke calls a method of an existing object
  optional Invoke invoke = 6;
  // 	 Delete removes the given object
  optional Delete delete = 7;
  // 	 Signatures that can be verified using the darc defined by the objectID.
  repeated Signature signatures = 8;
}

// ObjectID points to an object that holds the state of a contract.
message ObjectID {
  // 	 DarcID is the base ID of the Darc controlling access to this object
  required bytes darcid = 1;
  // 	 InstanceID is taken from the Instruction.Nonce when the Spawn instruction is
  // 	 sent.
  required bytes instanceid = 2;
}

// Spawn is called upon an existing object that will spawn a new object.
message Spawn {
  // 	 ContractID represents the kind of contract that needs to be spawn.
  required string contractid = 1;
  // 	 args holds all data necessary to spawn the new object.
  repeated Argument args = 2;
}

// Invoke calls a method of an existing object which will update its internal
// state.
message Invoke {
  // 	 Command is object specific and interpreted by the object.
  required string command = 1;
  // 	 args holds all data necessary for the successful execution of the command.
  repeated Argument args = 2;
}

// Delete removes the object.
message Delete {
}

// Argument is a name/value pair that will be passed to the object.
message Argument {
  // 	 Name can be any name recognized by the object.
  required string name = 1;
  // 	 Value must be binary marshalled
  required bytes value = 2;
}

// ClientTransaction is a slice of Instructions that will be applied in order.
// If any of the instructions fails, none of them will be applied.
message ClientTransaction {
  repeated Instruction instructions = 1;
}

// StateChange is one new state that will be applied to the collection.
message StateChange {
  // 	 StateAction can be any of Create, Update, Remove
  required sint32 stateaction = 1;
  // 	 ObjectID of the state to change
  required bytes objectid = 2;
  // 	 ContractID points to the contract that can interpret the value
  required bytes contractid = 3;
  // 	 Value is the data needed by the contract
  required bytes value = 4;
}
